I"O
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="err">짧은</span> <span class="err">요약</span> <span class="p">:</span>

<span class="no">Pythonic</span><span class="err">한</span> <span class="err">코딩을</span> <span class="err">위한</span> <span class="err">정리</span>  </code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># 전반적으로 다루려고 하는 것들</span>

<span class="o">-</span><span class="err">정렬된</span> <span class="err">리스트</span> <span class="err">탐색시</span> <span class="n">bisect</span><span class="err">사용</span>  
<span class="o">-</span><span class="err">별표식을</span> <span class="err">사용해</span> <span class="err">언패킹</span><span class="p">?</span> <span class="o">-&gt;</span><span class="err">오류</span> <span class="err">줄이는</span> <span class="err">방법</span><span class="p">?</span> <span class="sc">??</span>  
<span class="o">-</span><span class="n">zip</span><span class="err">을</span> <span class="err">사용하여</span> <span class="err">여러</span> <span class="err">리스트를</span> <span class="err">동시에</span> <span class="err">이터레이션하기</span><span class="o">!</span>  
<span class="o">-</span><span class="err">왈러스</span> <span class="err">연산자</span><span class="p">?</span> <span class="sc">??</span>  
<span class="o">-</span><span class="n">f</span><span class="o">-</span><span class="err">문자열</span> <span class="p">(</span><span class="o">+</span><span class="err">문자열</span><span class="p">,</span> <span class="err">바이트객체</span><span class="p">?).</span>  
<span class="nf">-</span><span class="n">typing</span> <span class="err">모듈</span><span class="p">?</span> <span class="sc">??</span>  
<span class="o">-</span><span class="err">대입식</span> <span class="p">??</span>  
<span class="o">-</span><span class="err">튜플의</span> <span class="err">나머지</span> <span class="err">원소를</span> <span class="err">모두</span> <span class="err">잡아내는</span> <span class="err">언패킹</span><span class="p">??</span>   

<span class="o">-</span><span class="err">매타클래스보다는</span> <span class="err">클래스</span> <span class="err">데코레이터를</span> <span class="err">사용하라</span> <span class="p">??</span>  
<span class="o">-</span><span class="n">__init_subclass__</span><span class="p">()</span> <span class="err">메서드</span> <span class="p">??</span>  
<span class="o">-</span><span class="err">동시성</span><span class="p">(</span> <span class="err">블로킹</span> <span class="no">I</span><span class="o">/</span><span class="no">O</span><span class="err">에는</span> <span class="err">스레드를</span> <span class="err">사용하지만</span><span class="p">,</span> <span class="err">병렬화를</span> <span class="err">위해</span> <span class="err">스레드를</span> <span class="err">사용하지</span> <span class="err">말라</span><span class="p">)</span> <span class="p">?</span><span class="sc">??</span>  
<span class="o">-</span><span class="err">강건성과</span> <span class="err">성능</span><span class="p">(</span><span class="err">최적화하기</span> <span class="err">전에</span> <span class="err">프로파일링하라</span><span class="p">)</span> <span class="p">?</span><span class="sc">??</span>  

<span class="o">-</span><span class="err">제너레이터</span>  
<span class="o">-</span><span class="err">이터레이터</span>  
<span class="o">-</span><span class="err">데코레이터</span>  
<span class="o">-</span><span class="err">왈러스</span> <span class="err">연산자</span>  
<span class="o">-</span><span class="err">다형성</span>  
<span class="o">-</span><span class="err">메타클래스</span>  
<span class="o">-</span><span class="err">디스크립터</span>  
<span class="o">-</span><span class="err">동시성</span><span class="o">/</span><span class="err">병렬성</span>  
<span class="o">-</span><span class="err">스레드</span>  
<span class="o">-</span><span class="err">큐</span>  
<span class="o">-</span><span class="err">코루틴</span>  
<span class="o">-</span><span class="err">이벤트</span> <span class="err">루프</span>  
<span class="o">-</span><span class="err">비동기</span>  
<span class="o">-</span><span class="err">프로파일링</span>  
<span class="o">-</span><span class="err">모킹과</span> <span class="err">테스트</span>  
<span class="o">-</span><span class="err">가상환경</span>  
<span class="o">-</span><span class="err">타입힌트</span>  
<span class="o">-</span><span class="err">경고</span>  </code></pre></figure>

<h1 id="pep8-python-enhancement-proposal8">PEP8 (Python Enhancement Proposal#8)</h1>

<p><em>공백관련(220221)<br />
**라인 길이는 79문자 이하<br />
**들여쓰기는 4칸 스페이스로<br />
**긴 식을 다음 줄에 이어서 쓸 경우 다음줄에 4스페이스 들여쓰기<br />
**각 함수와 클래스 사이에는 빈줄 두 줄<br />
**클래스 안에서 메서드와 메스드 사이는 빈칸 한 줄<br />
**딕셔너리의 키와 콜론(:) 사이에는 공백 없고, 한줄 안에 키-벨류 넣을 경우 콜론과 벨류 사이 공백하나<br />
**변수대입서 ‘=’ 전후 스페이스 하나<br />
**타입 표기를 덧붙이는 경우에는 변수 이름과 콜론 사이에 공백을 넣지 않고, 콜론과 타입 정보 사이에 스페이스 하나<br />
**</em>num = 1  # type: int (예시) -&gt; 타입 힌트 표기하는 것을 의미함</p>

<p>*명명관련(220222)<br />
**함수, 변수, 애트리뷰트(클래스 내부 함수, 변수)는 lowercase_underscore처럼 소문자와 언더바로<br />
**보호되야할 인스턴스의 애트리뷰트는 _leading_underscore처럼 앞에 언더바 사용<br />
**private(한 클래스 안에서만 쓰이고 다른 곳에서는 쓰면 안 되는) 인스턴스 애트리뷰트는 __leading_underscore처럼 앞에 언더바 두개 사용<br />
**클래시는 CapitalizedWord처럼 PascalCase 사용<br />
**모델(함수, 클래스 모아놓은 파일) 수준의 상수는 ALL_CAPS처럼 모든 글자를 대문자로 하고 단어와 단어 사이 언더바로<br />
**클래스에 들어 있는 인스턴스 메서드는 호출 대상 객체를 가리키는 첫번째 인자의 이름으로 반드시 self를 사용<br />
**클래스 메서드는 클래스를 가리키는 첫 번째 인자의 이름으로 반드시 cls를 사용<br />
(참고로 클래스는 설계도, 객체는 설계도로 구현한 대상, 인스턴스는 실제 소프트웨어로 구현된 것)<br />
(참고로 클래스 메서드는 인스턴스를 만들어 실체화 하지 않아도 클래스를 통해 직접적으로 호출 할 수 있음, cls로 클래스 호출)<br />
(참고로 인스턴스 메서드는 클래스를 통해 호출할 수 없고, 클래스의 인스턴스를 만들어 실체화 하여 생성된 인스턴스를 통해서 호출할 수 있음, self로 인스턴스 호출)<br />
(참고로 정적 메서드는 인스턴스, 클래스 애트리뷰트 접근/호출 못 함)</p>

<p>*expression and statement(식과 문)<br />
**긍정식을 부정하지 말고 부정을 내부에 넣어라(if not a is b –&gt; if a is not b)<br />
**빈 컨테이너(리스트, 딕셔너리, 세트), 빈 시퀀스(스트링, 리스트, 튜플) 체크할 때는 길이 체크보다는 False취급 사실 활용하라(if len(something) == 0 –&gt; if not 컨테이너)<br />
**마찮가지로 비어있지 않은 것을 체크할 때도 True 취급 활용(if len(someting) &gt; 0 –&gt; if 컨테이너)<br />
**한줄짜리 if문, for 루프, while 루프, except 문 사용하지 말고 여러 줄에 나눠라<br />
**식을 한줄 안에 다 쓸 수 없는 경우 식을 괄호로 둘러싸고 줄바꿈과 들여쓰기를 추가해서 가독성 높여라<br />
**여러줄에 걸쳐 식을 쓸 때는 줄이 계속된다는 표시를 하는 \문자 보다는 괄호를 사용하라</p>

<p>*임포트<br />
**import, from x import y는 항상 파일 맨 앞에 위치<br />
**모듈 임포트시 절대 경로를 사용하라(현재 기준으로 상대경로 사용 x, 예를 들어 bar패키지 foo라면 현재 bar패키지 안에 있더라도 from bar import foo라고 해야)<br />
**반드시 상대적 경로를 임포트해야 한다면 from . import foo처럼 사용<br />
**임포트를 적을 때는 표준라이브러리 모듈, 서드 파티 모듈, 사용자가 직접 만든 모듈 선서로 섹션을 나눠라, 그리고 알파벳 순서로 임포트하라</p>

<h1 id="f-string-사용하라-better-way-04">f-string 사용하라 (better way 04)</h1>

<p>*기존의 c style tuple or dictionary과 format 보다 간결하고, 명확하게 표현됨<br />
**비교</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s1">'my_values'</span><span class="p">,</span> <span class="mf">1.234</span>  
<span class="n">f_string</span> <span class="o">=</span> <span class="n">f</span><span class="s1">'{key:&lt;10}={value:.2f}'</span>  
<span class="n">c_tuple</span> <span class="o">=</span> <span class="s1">'%-10s = %.2f'</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>  
<span class="n">c_dict</span> <span class="o">=</span> <span class="s1">'%(key)-10s = %(value).2f'</span> <span class="o">%</span><span class="p">{</span><span class="s1">'key'</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="s1">'value'</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>  
<span class="n">str_args</span> <span class="o">=</span> <span class="s1">'{:&lt;10} = {:.2f}'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>  </code></pre></figure>

<p>**사용예</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s1">'my_values'</span><span class="p">,</span> <span class="mf">1.234</span>  
<span class="n">places</span><span class="p">,</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.23456</span>  
<span class="n">formatted</span> <span class="o">=</span> <span class="n">f</span><span class="s1">'{key} = {value}'</span>  
<span class="n">formatted</span> <span class="o">=</span> <span class="n">f</span><span class="s1">'내가 고른 숫자는 {number:.{places}f}'</span> <span class="c1">#하드코딩 대신 변수를 사용해 형식 문자열 안에 파라미터화함  </span></code></pre></figure>

<h1 id="range-보다는-enumerate를-사용하라yield에-대하여-betterway-07-220322">range 보다는 enumerate를 사용하라(yield에 대하여, betterway 07, 220322)</h1>

<p><em>yield는 generator를 만드는데 사용됨<br />
**결과값 반환할 때 return대신 사용하는 return과는 다소 다른 방식<br />
**</em>return list(“ABC”) vs yield “A” \n yield “B” \n yield “C”<br />
<em>**결과를 여러번 나누어서 제공<br />
**</em>return은 list를 반환하고 yield는 generator를 반환</p>

<p><em>그렇다면 generator는 무엇인가?<br />
**데이터 접근할 때 순차적으로 접근 가능하게 함<br />
**리스트라면 전부 접근해야해서 예를들어, 만개의 데이터가 들어있는 리스트라면<br />
처리시간 1초에 필요 메모리 1mb라 가정했을 때, 10000초와 10gb(10000mb)가 필요함<br />
**하지만 제너레이터는 순차적으로 하나씩 가져올 수 있어서 가져올 때마다 1초와 1mb로 처리<br />
**메모리 부족하거나 한번에 보여주지 않아도 될 때에 유용(그래서lazy iterator라고 불리기도)<br />
**이론적으로 무한데이터도 만들 수 있음<br />
**yield from을 쓰면 리스트를 바로 제너레이터로 변환할 수 있음<br />
**</em>yield from [“A”, “B”, “C”] 이런식으로<br />
<em>*리스트 표현식처럼 제너레이터 표현식도 있음<br />
**</em>abc = (ch for ch in “ABC”) 이런식</p>

<p><em>위와 비슷한 맥락에서 for i in range(len(something_list)): 대신<br />
it = enumerate(something_list)<br />
next(it)<br />
이렇게 쓸 수 있고 이 enumerate는 lazy generator(yield 사용 후 만들어지는)로 이루어져 있음<br />
**깔끔하게 for i, something in enumerate(something_list): 이렇게 짤 수 있음<br />
**enumerate에 두번째 파라미터를 지정해줘서 시작도 지정할 수 있음<br />
**</em>for i, something in enumerate(something_list, 1): 이런식으로..</p>

<h1 id="mutable과-imutable-자료구조220323-wednesday">mutable과 imutable 자료구조(220323 wednesday)</h1>
<p><em>가역적 비가역적.. 변하는 자료구조와 안 변하는 자료구조<br />
**가역적인 것은 대부분의 자료구조들 list, dictionary, set<br />
**비가역적인 것은 tuple.<br />
**</em>숫자형, 문자형 지정 변수도 비가역적..<br />
***비가역적 자료구조들은 변하지 않음 -&gt; 예를 들어, x=3이고 y=x라 했을 때 y += 1을 해도 x는 유지됨<br />
**mutable은 call-by-reference, immutable은 call-by-value로 볼 수 있음<br />
**참고문헌: https://ledgku.tistory.com/54</p>

<h1 id="복잡한-식을-쓰는-대신-도우미-함수를-작성하라better-way-5-220324-thursday">복잡한 식을 쓰는 대신 도우미 함수를 작성하라(Better way 5, 220324 thursday)</h1>
<p>*if/else 조건식으로 간결하게 표현도 가능한 경우 있음<br />
**사용예</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">red_str</span> <span class="o">=</span> <span class="n">my_values</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s1">'빨강'</span><span class="p">,</span> <span class="p">[</span><span class="s2">""</span><span class="p">])</span>  
<span class="n">red</span> <span class="o">=</span> <span class="n">int</span><span class="p">(</span><span class="n">red_str</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">red_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>  </code></pre></figure>

<p>*하지만 두세번만 반복되는 경우에도 함수 따로 만드는 것 권장<br />
**사용예</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">get_first_int</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">efault</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>  
    <span class="n">found</span> <span class="o">=</span> <span class="n">values</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[</span><span class="s2">""</span><span class="p">])</span>  
    <span class="k">if</span> <span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  
        <span class="k">return</span> <span class="n">int</span><span class="p">(</span><span class="n">found</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
    <span class="k">return</span> <span class="n">default</span>  </code></pre></figure>

<h1 id="인덱스-대신-언패킹해라better-way-6-220324-thursday">인덱스 대신 언패킹해라(Better way 6, 220324 thursday)</h1>
<p>*지양하는 사용예</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">listA</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"korean"</span><span class="p">,</span> <span class="s2">"kimchi"</span><span class="p">),</span> <span class="p">(</span><span class="s2">"italian"</span><span class="p">,</span><span class="s2">"pasta"</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">listA</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">listA</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></code></pre></figure>

<p>*지향하는 사용예</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">listA</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"korean"</span><span class="p">,</span> <span class="s2">"kimchi"</span><span class="p">),</span> <span class="p">(</span><span class="s2">"italian"</span><span class="p">,</span><span class="s2">"pasta"</span><span class="p">)]</span>
<span class="k">for</span> <span class="p">(</span><span class="n">national</span><span class="p">,</span> <span class="n">food</span><span class="p">)</span> <span class="k">in</span> <span class="ss">listA:
    </span><span class="nb">print</span><span class="p">(</span> <span class="p">(</span><span class="n">national</span><span class="p">,</span> <span class="n">food</span><span class="p">)</span> <span class="p">)</span></code></pre></figure>

<h1 id="better-way-8910friday-220325-">Better way 8,9,10(Friday, 220325 )</h1>
<p><em>zip을 사용하라<br />
**(참고)리스트 컴프리헨션 사용하면 새로운 리스트 만들기 편함<br />
**</em>counts = [len(n) for n in names] #names = [‘Zelenskyy’, ‘우크라이나’] #결과=[9,5]<br />
<em>*두개 리스트 접근할 때 zip 편함<br />
**</em>사용예</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">for</span> <span class="nb">name</span><span class="p">,</span> <span class="n">count</span> <span class="k">in</span> <span class="n">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">'{name}: {count}'</span><span class="p">)</span></code></pre></figure>

<p><strong>**다만 길이가 다를 경우에는 작은 길이까지만 고려해줌<br />
**</strong>이 경우, zip_longest를 사용하면 짧은 경우에는 None을 넣어줌</p>

<p><em>loop 이후에 else블록 사용하지 말아라<br />
*월러스 연산자 ( := ) 사용해서 대입 반복 피하라<br />
**월러스 연산자는 대입연산자로 대입 해줌.. 이후 조건 체크 바로 해줄 수 있어서 편함<br />
**</em>사용예</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">while</span> <span class="n">fresh_fruit</span> <span class="p">:</span><span class="o">=</span> <span class="n">pick_fruit</span><span class="p">():</span> <span class="c1">#fresh_fruit에 값 넣어줌, 만약 없으면 break됨  </span>


<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="p">:</span><span class="o">=</span> <span class="n">fresh_fruit</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s1">'레몬'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span> <span class="c1">#카운트에 개수 세서 넣어줌. 뒤에 조건문 붙여줘서 한줄로 편하게 처리  </span></code></pre></figure>

:ET